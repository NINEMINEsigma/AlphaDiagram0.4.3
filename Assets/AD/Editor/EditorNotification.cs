using UnityEditor; using UnityEngine; using System.IO; using System.Collections.Generic; using AD; using System; using static EditorNotification;  [Serializable] public class MD5File {     public Dictionary<string, string> m_DicMD5 = new Dictionary<string, string>(); }  public class EditorNotificationToolsWindow : EditorWindow {     public void OnGUI()     {         Setting setting = new Setting();         if (ADGlobalSystem.Input<Setting>(ResPath, out object temp_set))         {             setting = temp_set as Setting;         }          GUILayout.BeginVertical();         GUILayout.Space(10);         {             GUILayout.Label("EditorNotification Setting");             {                 GUILayout.BeginHorizontal();                 GUILayout.Label("是否开启 Is Using EditorNotification Refresh");                 if (setting.IsUsingEditorNotificationRefresh != GUILayout.Toggle(setting.IsUsingEditorNotificationRefresh, ""))                 {                     setting.IsUsingEditorNotificationRefresh = !setting.IsUsingEditorNotificationRefresh;                     if (SetLockReloadAssemblies(setting.IsUsingEditorNotificationRefresh))                         ADGlobalSystem.Output(ResPath, setting);                 }                 GUILayout.EndHorizontal();             }             if (setting.IsUsingEditorNotificationRefresh)             {                 GUILayout.Space(10);                 {                     GUILayout.BeginVertical();                     GUILayout.Label("默认搜索路径 ScriptPath");                     string temp = GUILayout.TextField(setting.scriptPath, GUILayout.Width(500), GUILayout.Height(20));                     if (setting.scriptPath != temp)                     {                         setting.scriptPath = temp;                         ADGlobalSystem.Output(ResPath, setting);                     }                     GUILayout.EndVertical();                 }                 GUILayout.Space(10);                 {                     GUILayout.BeginHorizontal();                     GUILayout.Label("是否总是在播放前提醒 Is Keeping Entered PlayMode Warning");                     if (setting.IsKeepingEnteredPlayModeWarning != GUILayout.Toggle(setting.IsKeepingEnteredPlayModeWarning, ""))                     {                         setting.IsKeepingEnteredPlayModeWarning = !setting.IsKeepingEnteredPlayModeWarning;                         ADGlobalSystem.Output(ResPath, setting);                     }                     GUILayout.EndHorizontal();                 }                 GUILayout.Space(10);                 {                     GUILayout.BeginHorizontal();                     GUILayout.Label("展示搜索信息 Is Show Message");                     if (setting.isShowMessage != GUILayout.Toggle(setting.isShowMessage, ""))                     {                         setting.isShowMessage = !setting.isShowMessage;                         ADGlobalSystem.Output(ResPath, setting);                     }                     GUILayout.EndHorizontal();                 }                 if (setting.isShowMessage)                 {                     GUILayout.Space(10);                     {                         GUILayout.BeginHorizontal();                         GUILayout.Label("  使用红色显示 Is Using ErrorBox");                         if (setting.IsShowMessageUsingErrorBox != GUILayout.Toggle(setting.IsShowMessageUsingErrorBox, ""))                         {                             setting.IsShowMessageUsingErrorBox = !setting.IsShowMessageUsingErrorBox;                             ADGlobalSystem.Output(ResPath, setting);                         }                         GUILayout.EndHorizontal();                     }                 }             }         }         GUILayout.Space(10);         if (GUILayout.Button("保存设置"))         {             if (SetLockReloadAssemblies(setting.IsUsingEditorNotificationRefresh))                 ADGlobalSystem.Output(ResPath, setting);         }         GUILayout.EndVertical();     }      private static bool SetLockReloadAssemblies(bool boolen)     {         if (boolen)         {             if (EditorUtility.DisplayDialog("提醒", "是否使用EditorNotification来加载程序集 \n\n确认后不会由UnityEditor执行程序集的自动加载", "确认", "取消"))             {                 Debug.Log("程序集已锁定。");                 EditorApplication.LockReloadAssemblies();             }             else return false;         }         else         {             Debug.Log("已回复自动加载程序集");             EditorApplication.UnlockReloadAssemblies();         }         return true;     } }  [InitializeOnLoad] public class EditorNotification : AssetPostprocessor {     [Serializable]     public class Setting     {         public string scriptPath;         public bool isShowMessage;         public bool IsShowMessageUsingErrorBox;         public bool IsUsingEditorNotificationRefresh;         public bool IsKeepingEnteredPlayModeWarning;          public Setting() : this(DataPath, true, true, true, true)         {          }         public Setting(string scriptPath, bool isShowMessage, bool IsShowMessageUsingErrorBox, bool isUsingEditorNotificationRefresh, bool IsKeepingEnteredPlayModeWarning)         {             this.scriptPath = scriptPath;             this.isShowMessage = isShowMessage;             this.IsShowMessageUsingErrorBox = IsShowMessageUsingErrorBox;             this.IsUsingEditorNotificationRefresh = isUsingEditorNotificationRefresh;             this.IsKeepingEnteredPlayModeWarning = IsKeepingEnteredPlayModeWarning;         }     }      public static string DataPath => Application.dataPath;     public static string SourcePath => $"{DataPath}/../Library/AlphaDiagram";     public static string ResourceFileName => "setting.ednot";     public static string Md5RefreshRecord => "md5Refresh.json";     public static string Md5Path => Path.Combine(SourcePath, Md5RefreshRecord);     public static string ResPath => Path.Combine(SourcePath, ResourceFileName);      private static bool isFocused;     static EditorNotification()     {         EditorApplication.update -= Update;         EditorApplication.update += Update;         EditorApplication.playModeStateChanged -= PlaymodeStateChanged;         EditorApplication.playModeStateChanged += PlaymodeStateChanged;         Setting setting = new Setting();         if (ADGlobalSystem.Input<Setting>(ResPath, out object temp_set))         {             setting = temp_set as Setting;         }         SetLockReloadAssembliesNoWarning(setting.IsUsingEditorNotificationRefresh);     }      private static void Update()     {         if (isFocused != UnityEditorInternal.InternalEditorUtility.isApplicationActive)         {             isFocused = UnityEditorInternal.InternalEditorUtility.isApplicationActive;             OnEditorFocus(isFocused);         }     }      private static void PlaymodeStateChanged(PlayModeStateChange state)     {         Setting setting = new Setting();         if (ADGlobalSystem.Input<Setting>(ResPath, out object temp_set))         {             setting = temp_set as Setting;         }         if (!setting.IsUsingEditorNotificationRefresh) return;         if (state == PlayModeStateChange.ExitingEditMode && setting.IsKeepingEnteredPlayModeWarning)         {             if (!EditorUtility.DisplayDialog("提醒", "已取消自动加载程序集，请注意", "确定", "返回"))             {                 EditorApplication.isPlaying = false;             }         }         SetLockReloadAssembliesNoWarning(setting.IsUsingEditorNotificationRefresh);     }      private static void OnEditorFocus(bool focus)     {         if (focus && !EditorApplication.isPlaying && !EditorApplication.isPlayingOrWillChangePlaymode)         {             Refresh();         }     }

    //private void OnPreprocessAsset()
    //{
    //    //Debug.LogError("Asset下文件改变时回调");
    //} 

    [MenuItem("File/RefreshManual")]     static void ImmDRefresh()     {         EditorUtility.RequestScriptReload();     }      static void Refresh()     {         Setting setting = new Setting();         if (ADGlobalSystem.Input<Setting>(ResPath, out object temp_set))         {             setting = temp_set as Setting;         }          if (!setting.IsUsingEditorNotificationRefresh) return;          MD5File md5 = new MD5File();         if (ADGlobalSystem.Input<MD5File>(Md5Path, out object temp_md5))         {             md5 = temp_md5 as MD5File;         }          bool needRefresh = false;         System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();         sw.Reset();         sw.Start();          var fileInfos = AD.BASE.FileC.FindAll(setting.scriptPath, "cs", SearchOption.AllDirectories);         foreach (FileInfo file in fileInfos)         {             string timestr = file.LastWriteTime.ToLongTimeString();             if (md5.m_DicMD5.TryGetValue(file.FullName, out string value))             {                 if (!System.DateTime.Equals(System.DateTime.Parse(value), System.DateTime.Parse(timestr)))                 {                     needRefresh = true;                     md5.m_DicMD5[file.FullName] = timestr;                     string message = file.FullName + " - " + value + " -- " + timestr;                     if (setting.isShowMessage)                     {                         if (setting.IsShowMessageUsingErrorBox) Debug.LogError(message);                         else Debug.Log(message);                     }                 }             }             else             {                 needRefresh = true;                 md5.m_DicMD5.Add(file.FullName, timestr);                 string message = file.FullName + " -------- " + timestr;                 if (setting.isShowMessage)                 {                     if (setting.IsShowMessageUsingErrorBox) Debug.LogError(message);                     else Debug.Log(message);                 }             }         }          ADGlobalSystem.Output(Md5Path, md5);         sw.Stop();         if (needRefresh)         {             string str = "C#变更检查结束---刷新 ";             string t = (sw.Elapsed.TotalMilliseconds / 1000).ToString("N2");             Debug.LogError($"{str}FileCount:{fileInfos.Count} Time:{t}秒");             AssetDatabase.Refresh();             EditorUtility.RequestScriptReload();
        }     }      private static void SetLockReloadAssembliesNoWarning(bool boolen)     {         if (boolen)         {             Debug.LogWarning("程序集已锁定");             EditorApplication.LockReloadAssemblies();         }         else         {             Debug.Log("已交给UnityEditor自动加载程序集");             EditorApplication.UnlockReloadAssemblies();         }     } } 